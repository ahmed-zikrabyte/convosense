# 1) Quick glossary (so mappings read fast)

- Campaign = what the client creates in your UI (script, KB, flow, settings, leads).
- Lead = a phone number + dynamic variables.
- Agent = the voice/AI object on Retell that runs the script/flow.
- Batch call = Retell bulk outbound call job.
- Collections you will use (recommended): `clients`, `campaigns`, `leads`, `agents`, `phone_numbers`, `batch_calls`, `calls`, `transactions`, `reports`, `webhook_events`, `audit_logs`.

# 2) Onboarding (Super Admin creates client)

Client action (client sees nothing; Super Admin action)

- UI: Super Admin creates client account, assigns plan/price-per-minute, and optionally seeds credits.
- Backend (your system):
  - Create `clients` document: `{ clientId, name, contact, credits_total_minutes, credits_available_minutes, billing_rate, status }`.
  - Create initial transaction record in `transactions` for the credit purchase (type: purchase, minutes_added, amount, billing_meta).

- Retell calls: none.
- Mongo: `clients`, `transactions`, `audit_logs`.

# 3) Campaign creation (client builds campaign)

Client action

- In your UI client clicks "New Campaign", enters: campaign name, script (text/prompts), uploads knowledge files or URLs, edits/visually builds flow nodes (optional), picks voice + basic call settings (max call duration, ring time), chooses dynamic variables.

Backend actions and Retell mapping

1. Persist campaign draft in MongoDB
   - `campaigns` doc: `{ campaignId, clientId, name, script_raw, kb_files_meta, flow_json, voice_id, settings, status: 'draft' }`.

2. If client uploaded knowledge (files / URLs / text)
   - Call Retell `POST /create-knowledge-base` with files/text/urls. Save `knowledge_base_id` returned. ([docs.retellai.com][1])
   - Store mapping in Mongo: `campaigns[kb]` and `agents` temp metadata.

3. If client used conversation-flow UI
   - Transform the UI flow into Retell nodes JSON and call `POST /create-conversation-flow`. Save `conversation_flow_id` and version. ([docs.retellai.com][2])
   - Update `campaigns` with `conversation_flow_id`.

4. Create response engine if using Retell LLM approach (optional)
   - Call `POST /create-retell-llm` if you want single/multi prompt engine and save `llm_id`. ([docs.retellai.com][3])

5. Create agent that ties voice + response engine (conversation_flow or llm)
   - Call `POST /create-agent` with `response_engine` referencing the conversation_flow or llm id, and `voice_id` + agent settings (webhook_url optional). Save `agent_id` and initial `version`. ([docs.retellai.com][4])

6. Optionally publish now or later
   - When client clicks "Deploy" or "Publish", call `POST /publish-agent/{agent_id}` so you have a stable version for production use. Save published_version on `campaigns`. ([docs.retellai.com][5])

7. Mongo: `campaigns` (campaign + retell ids), `agents` (mirrors agent_id, version, agent settings), `audit_logs`.

Notes

- Edits: when client updates script/flow/KB, call `PATCH /update-conversation-flow` and `PATCH /update-agent` and then `publish-agent` again to deploy. Save each new draft/version in your DB. ([docs.retellai.com][6])

# 4) Phone numbers and leads (client attaches numbers and uploads leads)

Client action

- Client either (A) selects an existing "from" number you provision for their campaigns or (B) requests purchasing/importing a number, then uploads leads via CSV or table.

Backend actions and Retell mapping

1. Phone number provisioning (if needed)
   - Option A - Buy from Retell: `POST /create-phone-number` (buy number and bind to agent inbound/outbound). Save purchased `phone_number`. ([docs.retellai.com][7])
   - Option B - Import existing telco/SIP number: `POST /import-phone-number` with termination_uri / trunk details; save returned `phone_number`. ([docs.retellai.com][8])
   - Store phone numbers in Mongo: `phone_numbers` collection with provider, inbound_agent_id, outbound_agent_id, pretty_number, last_mod_ts.

2. Leads upload
   - Validate/normalize numbers to E.164, dedupe, create `leads` docs: `{ leadId, campaignId, clientId, phone_number, dynamic_vars, status: 'not_called' }`.
   - Provide UI preview showing estimated minutes and required credits (simple estimate = expected_call_min_per_lead \* count).

3. Optional: For large imports create a staging `lead_imports` doc with CSV metadata and parsing errors logged.

# 5) Launch campaign (client clicks Launch)

Client action

- Client clicks Launch (immediate or scheduled), picks which from_number to use.

Backend actions and Retell mapping

1. Pre-check credits (your system)
   - Compute estimate: `est_minutes = leads_count * expected_minutes_per_lead` (your choice of estimator).
   - If `client.credits_available_minutes < est_minutes` then return "insufficient credits" and prompt purchase. No Retell call. Mongo unchanged.

2. Reserve credits (strongly recommended)
   - Create a `transactions` entry: `{ txId, clientId, campaignId, type: 'reserve', minutes_reserved: est_minutes, status: 'pending' }`.
   - Update client doc: `credits_available_minutes -= est_minutes` OR store `credits_reserved_minutes` separately so available = total - reserved - consumed.
   - Mongo: `transactions`, `clients` updated.

3. Kick off calls - recommended: Batch approach
   - For scale call Retell `POST /create-batch-call` with `from_number` and `tasks[]` where each task has `to` phone and `variables` for dynamic personalization and optional `trigger_timestamp` for scheduling. Save returned `batch_call_id`. ([docs.retellai.com][9])
     - Save batch info in `batch_calls` collection: `{ batch_call_id, campaignId, clientId, total_tasks, scheduled_timestamp, status }`.

   - Alternative for fine control or per-lead tracking: run `POST /v2/create-phone-call` per lead (one network call per call). Use for small lists or when you need per-call immediate feedback. Save each Retell `call_id`. ([docs.retellai.com][10])

4. Mark leads as scheduled/launched in `leads` table with references to batch_task_id or call_id.
5. Audit/log the launch event in `audit_logs`.

Notes

- Batch call is the right pattern for CSV uploads from UI: user uploads CSV, you create batch with tasks. Retell supports dynamic variables in CSV and scheduling. ([docs.retellai.com][11])

# 6) Runtime - call lifecycle, webhook handling, and credit reconciliation

What your system must do while calls run

1. Webhook setup
   - Configure an endpoint in your system and set it in your Retell agent `webhook_url` (or set globally) so Retell posts events: call_started, call_completed, call_analyzed (post-call analysis), etc. Verify signatures via `x-retell-signature`. ([docs.retellai.com][12])

2. Webhook event processing (on each event)
   - Persist the raw event in `webhook_events` for replay and auditing.
   - Update `calls` collection per call: `{ callId, campaignId, leadId, agentId, from, to, status, start_ts, end_ts, duration_seconds, transcript, call_analysis, call_cost }`.
   - Important: use `call_analyzed` or final `call_completed` webhook to get final `call_cost` and `post_call_analysis_data`; Retell returns `call_cost`, `duration_ms`, `transcript`, `call_analysis`. Use that data to bill. ([docs.retellai.com][13])

3. Deduct actual minutes and finalize transaction
   - Compute actual minutes consumed for billing - recommended: use Retell `call_cost` or `duration_seconds` field from webhook to compute minutes. Retell returns a `call_cost` object you can use instead of estimating. Store `call_cost` exactly in the `calls` doc. ([docs.retellai.com][13])
   - Create a `transactions` doc per call: `{ txId, clientId, campaignId, callId, type: 'consume', minutes_used, amount_usd, details: call_cost }`.
   - Reconcile reserve: subtract `minutes_used` from campaign reservation. If the campaign used less than reserved, add leftover minutes back to `credits_available_minutes` and update the reservation `transactions` status accordingly. If the campaign exceeded reservation, either:
     - (a) Auto-purchase / block further calls and notify client, or
     - (b) Allow negative balance and invoice later. Your choice; implement clear policy.

4. Update lead status: `called`, `no_answer`, `answered`, `converted` (if conversion identified in `call_analysis`).
5. For transcripts/insights: store transcripts and structured `call_analysis` fields (sentiment, extracted fields) in `calls` and also in `reports` / `leads` as needed.
6. Mongo: `webhook_events`, `calls`, `transactions`, `leads`, `clients` (credits).

# 7) Reporting and analytics (client & super-admin)

Client action

- Client goes to Campaign Report, sees per-campaign metrics and per-lead call logs and transcripts.

Backend actions

- Build reports by aggregating `calls` and `transactions` for campaignId:
  - Metrics: total calls, answered, pick-up rate, average duration, total minutes consumed, total cost, top keywords from `call_analysis`, leads converted.

- Store pre-computed report snapshots in `reports` for quick dashboard reads: `{ reportId, campaignId, clientId, metrics, generated_at }`.
- Super Admin view: run aggregated queries across `campaigns`/`clients` to produce consolidated reports and export CSVs.
- Retell side: you can also poll their `GET list-calls` or rely on webhook events; webhook is preferable. ([docs.retellai.com][13])

# 8) Edit/update campaign after launch

Client action

- Client edits script, KB, flow, voice settings.

Backend actions and Retell mapping

- Update KB: `PATCH` or `POST /create-knowledge-base` new one + attach -> store new `knowledge_base_id`. ([docs.retellai.com][1])
- Update conversation flow: `PATCH /update-conversation-flow` then update agent `PATCH /update-agent` and optionally `POST /publish-agent/{agent_id}` to deploy new version. Save new versions in `agents` and `campaigns`. ([docs.retellai.com][6])

# 9) Failure handling, retries, and back-pressure

- If create-batch-call or create-phone-call returns transient errors:
  - Retry with exponential backoff and idempotency keys.
  - On partial batch failures, mark failed tasks in `batch_calls` and requeue.

- Monitor `get-concurrency` limits to avoid hitting concurrency caps. Use `GET /get-concurrency` to plan rollout. ([docs.retellai.com][14])

# 10) Data you must keep in MongoDB (concise schema suggestions)

- `clients` - `{ clientId, name, credits_total_minutes, credits_reserved_minutes, credits_consumed_minutes, billing_rate, contact }`
- `transactions` - `{ txId, clientId, type: purchase|reserve|consume|refund|adjustment, minutes, amount_usd, referenceId, status, createdAt }`
- `campaigns` - `{ campaignId, clientId, name, agent_id, conversation_flow_id, kb_ids[], from_number, status, published_version }`
- `agents` - `{ agentId, clientId, voice_id, response_engine_type, response_engine_id, version, webhook_url }`
- `phone_numbers` - `{ phone_number, provider, inbound_agent_id, outbound_agent_id, type, imported }`
- `leads` - `{ leadId, campaignId, phone_number, dynamic_vars, status, last_attempted_at, last_call_id }`
- `batch_calls` - `{ batchId, campaignId, clientId, tasks_count, scheduled_ts, status }`
- `calls` - `{ callId, campaignId, leadId, agentId, from, to, start_ts, end_ts, duration_seconds, call_cost, transcript, call_analysis, status }`
- `webhook_events` - raw events for replay
- `reports` - precomputed metrics per campaign / date

# 11) Billing/credits recommended rules (practical)

- Use Retell `call_cost` and `duration_seconds` from final webhook to bill; do not estimate after the fact. Retell returns a `call_cost` object and durations in the call response/webhook. Use that as source-of-truth. ([docs.retellai.com][13])
- Reserve estimated minutes at campaign launch (create a pending transaction) and deduct actual minutes after each call finishes (final `consume` transaction). This prevents overspend and simplifies refunds.
- Keep per-call `transactions` for audit and refunds.

# 12) Webhooks and security (must-have)

- Register your endpoint and verify `x-retell-signature` header on incoming calls. Store raw payloads for debugging and replay. ([docs.retellai.com][12])
- Keep Retell API keys in your server env, not in client code.
- Consider per-client Retell workspaces/API keys if you need strict isolation; otherwise a single master key works but mixes metadata in Retell.

# 13) Quick reference mapping (for devs)

- Create Knowledge Base - `POST /create-knowledge-base`. Use for uploaded files/text/URLs. ([docs.retellai.com][1])
- Create Conversation Flow - `POST /create-conversation-flow`. Use for flow JSON from your visual builder. ([docs.retellai.com][2])
- Create Retell LLM - `POST /create-retell-llm`. Use for single/multi-prompt agents if chosen. ([docs.retellai.com][3])
- Create Agent - `POST /create-agent`. Attach response engine + voice. Save `agent_id`. ([docs.retellai.com][4])
- Publish Agent - `POST /publish-agent/{agent_id}`. Use to create a production version. ([docs.retellai.com][5])
- Buy Number - `POST /create-phone-number`. Or Import - `POST /import-phone-number`. ([docs.retellai.com][7])
- Launch calls - Bulk: `POST /create-batch-call`. Single: `POST /v2/create-phone-call`. ([docs.retellai.com][9])
- Webhook events - receive call lifecycle, final analyses, and call_cost via webhooks. Validate `x-retell-signature`. ([docs.retellai.com][12])
- Update flow/agent - `PATCH /update-conversation-flow` and `PATCH /update-agent`. ([docs.retellai.com][6])

# 14) Final practical callouts - the stuff that saves you time

- Use `create-batch-call` for CSV uploads - that maps directly to the campaign CSV UI. ([docs.retellai.com][9])
- Always reconcile credits with the `call_cost` Retell provides - that object is the authoritative charge per call. ([docs.retellai.com][13])
- Use webhooks, not polling - webhooks include post-call analysis and cost details. ([docs.retellai.com][12])
- Keep a transaction ledger and reserve on launch - it avoids angry clients. Be explicit in the UI about "reserved minutes".
- Log everything in `webhook_events` so you can replay and audit contested calls.

[1]: https://docs.retellai.com/api-references/create-knowledge-base "Create Knowledge Base - Retell AI"
[2]: https://docs.retellai.com/api-references/create-conversation-flow "Create Conversation Flow - Retell AI"
[3]: https://docs.retellai.com/api-references/create-retell-llm?utm_source=chatgpt.com "Create Retell LLM"
[4]: https://docs.retellai.com/api-references/create-agent "Create Agent - Retell AI"
[5]: https://docs.retellai.com/api-references/publish-agent?utm_source=chatgpt.com "Publish Agent"
[6]: https://docs.retellai.com/api-references/update-conversation-flow "Update Conversation Flow - Retell AI"
[7]: https://docs.retellai.com/api-references/create-phone-number?utm_source=chatgpt.com "Create Phone Number"
[8]: https://docs.retellai.com/api-references/import-phone-number?utm_source=chatgpt.com "Import Phone Number"
[9]: https://docs.retellai.com/api-references/create-batch-call?utm_source=chatgpt.com "Create Batch Call"
[10]: https://docs.retellai.com/api-references/create-phone-call?utm_source=chatgpt.com "Create Phone Call"
[11]: https://docs.retellai.com/deploy/create-batch-call?utm_source=chatgpt.com "Create batch calls"
[12]: https://docs.retellai.com/features/register-webhook?utm_source=chatgpt.com "Setup guide"
[13]: https://docs.retellai.com/api-references/list-calls?utm_source=chatgpt.com "List Calls"
[14]: https://docs.retellai.com/api-references/get-concurrency?utm_source=chatgpt.com "Get Concurrency"

few updates / addons frm above flow.

1. when creating campaign no need of visual flow building keep it simple
2. client wont be creating phone number, super admin be adding phone numbers to them and assign to clients
3. we to also want to see how much each call cost us (me super admin) from retell ai so that i can see if am making profit or loss. like i need complete details of each call and a client like how much he has cost us on retell ai, client musnt see this pricing this is only to show to the superadmin
